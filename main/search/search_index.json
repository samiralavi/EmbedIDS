{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#embedids-open-source-intrusion-detection-system-ids-for-embedded-systems","title":"EmbedIDS: Open Source Intrusion Detection System (IDS) for Embedded Systems","text":"<p>\ud83d\ude80 New to EmbedIDS?  - Quick Start Guide - Get running in 5 minutes - Complete Tutorial - Comprehensive learning guide - Examples - Ready-to-run code samples</p> <p>EmbedIDS is a lightweight Runtime Intrusion Detection SDK specifically designed for low-power embedded Internet of Things (IoT) devices. Our open-source SDK provides AI-driven protection to address the critical security gap in constrained IoT environments.</p>"},{"location":"#overview","title":"Overview","text":"<p>EmbedIDS provides on-device, AI-driven protection tailored to resource-constrained embedded systems. By deploying compact anomaly-detection agents directly on devices, we enable real-time protection without relying on external connectivity or cloud dependencies.</p>"},{"location":"#product-features","title":"Product Features","text":""},{"location":"#open-source-sdk-apache-20-licensed","title":"Open-Source SDK (Apache 2.0 Licensed)","text":"<p>Our free SDK empowers developers to secure embedded devices at no cost, featuring:</p> <ul> <li>Lightweight on-device intrusion detection system</li> <li>Fixed-logic detection models optimized for low-power environments</li> <li>Zero licensing fees for developers and deployments</li> <li>Apache 2.0 license ensuring maximum flexibility and adoption</li> <li>Customizable metric collection for device-specific monitoring</li> <li>AI-model training tools for tailored threat detection</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#on-device-intelligence","title":"On-Device Intelligence","text":"<ul> <li>Real-time anomaly detection without cloud dependency</li> <li>Compact ML models optimized for embedded constraints</li> <li>Behavioral analysis tailored to device-specific operations</li> <li>Low resource footprint suitable for IoT devices</li> </ul>"},{"location":"#customizable-security","title":"Customizable Security","text":"<ul> <li>Define custom behavioral metrics based on device functionality</li> <li>Train specialized ML models using our development tools</li> <li>Deploy targeted protection for specific threat vectors</li> <li>Adaptive monitoring that evolves with device behavior</li> </ul>"},{"location":"#developer-friendly-design","title":"Developer-Friendly Design","text":"<ul> <li>Easy integration with existing embedded systems</li> <li>Minimal configuration required for basic protection</li> <li>Comprehensive documentation and examples</li> <li>Active community support for open-source users</li> </ul>"},{"location":"#why-embedids","title":"Why EmbedIDS?","text":"<p>The IoT security landscape faces unique challenges:</p> <ul> <li>Resource constraints limit traditional security solutions</li> <li>Connectivity issues make cloud-dependent protection unreliable</li> <li>Scale requirements demand cost-effective deployment models</li> <li>Diverse hardware needs flexible, adaptable solutions</li> </ul> <p>EmbedIDS addresses these challenges by providing:</p> <ol> <li>On-device protection that works offline</li> <li>Lightweight implementation suitable for constrained devices</li> <li>Open-source model enabling rapid adoption and community collaboration</li> <li>AI-driven detection for sophisticated threat identification</li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Start securing your embedded devices immediately with our open-source SDK:</p> <ol> <li>Download the SDK from our repository</li> <li>Integrate the lightweight SDK into your device</li> <li>Configure intrusion detection rules for your use case</li> <li>Train custom ML models using our development tools</li> <li>Deploy with confidence knowing your devices are protected</li> </ol>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Industrial IoT sensors monitoring critical infrastructure</li> <li>Smart home devices protecting personal networks</li> <li>Medical IoT devices ensuring patient safety and privacy</li> <li>Automotive embedded systems securing connected vehicles</li> <li>Edge computing nodes protecting distributed networks</li> </ul>"},{"location":"#community-and-support","title":"Community and Support","text":"<p>EmbedIDS thrives on open-source collaboration and community contribution:</p> <ul> <li>Active open-source community for developers and researchers</li> <li>Community support through forums and documentation</li> <li>Regular updates and security patches</li> <li>Comprehensive documentation and tutorials for all skill levels</li> <li>Contribution guidelines for community developers</li> </ul> <p>Ready to secure your embedded devices? Download our open-source SDK and join the community!</p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#quick-start","title":"Quick Start","text":"<p>Get up and running with EmbedIDS in 5 minutes!</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>git clone https://github.com/samiralavi/EmbedIDS.git\ncd EmbedIDS\nmkdir build &amp;&amp; cd build\ncmake ..\nmake\n</code></pre>"},{"location":"quickstart/#hello-world-example","title":"Hello World Example","text":"<p>Create <code>my_monitor.c</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include \"embedids.h\"\n\nint main() {\n    // 1. Allocate memory for metric history\n    static embedids_metric_datapoint_t cpu_history[50];\n\n    // 2. Configure CPU metric\n    embedids_metric_t cpu_metric;\n    memset(&amp;cpu_metric, 0, sizeof(cpu_metric));\n    strcpy(cpu_metric.name, \"cpu_usage\");\n    cpu_metric.type = EMBEDIDS_METRIC_TYPE_PERCENTAGE;\n    cpu_metric.history = cpu_history;\n    cpu_metric.max_history_size = 50;\n    cpu_metric.enabled = true;\n\n    // 3. Configure threshold algorithm (alert if CPU &gt; 80%)\n    embedids_algorithm_t threshold_algo;\n    memset(&amp;threshold_algo, 0, sizeof(threshold_algo));\n    threshold_algo.type = EMBEDIDS_ALGORITHM_THRESHOLD;\n    threshold_algo.enabled = true;\n    threshold_algo.config.threshold.max_threshold.f32 = 80.0f;\n    threshold_algo.config.threshold.check_max = true;\n\n    // 4. Create metric configuration\n    embedids_metric_config_t metric_config;\n    memset(&amp;metric_config, 0, sizeof(metric_config));\n    metric_config.metric = cpu_metric;\n    metric_config.algorithms[0] = threshold_algo;\n    metric_config.num_algorithms = 1;\n\n    // 5. Create system configuration\n    embedids_system_config_t system_config;\n    memset(&amp;system_config, 0, sizeof(system_config));\n    system_config.metrics = &amp;metric_config;\n    system_config.max_metrics = 1;\n    system_config.num_active_metrics = 1;\n\n    // 6. Initialize EmbedIDS context and system\n    embedids_context_t context;\n    memset(&amp;context, 0, sizeof(context));\n\n    if (embedids_init(&amp;context, &amp;system_config) != EMBEDIDS_OK) {\n        printf(\"Failed to initialize EmbedIDS\\n\");\n        return 1;\n    }\n\n    printf(\"\ud83d\udd12 CPU Monitor Started (threshold: 80%%)\\n\\n\");\n\n    // 7. Monitoring loop\n    for (int i = 0; i &lt; 10; i++) {\n        // Simulate CPU usage (gradually increasing)\n        float cpu = 30.0f + (i * 8.0f);\n\n        // Add data point\n        embedids_metric_value_t value = {.f32 = cpu};\n        embedids_add_datapoint(&amp;context, \"cpu_usage\", value, time(NULL) * 1000);\n\n        // Check for threats\n        if (embedids_analyze_metric(&amp;context, \"cpu_usage\") == EMBEDIDS_OK) {\n            printf(\"\u2705 CPU: %.1f%% - Normal\\n\", cpu);\n        } else {\n            printf(\"\ud83d\udea8 CPU: %.1f%% - ALERT!\\n\", cpu);\n        }\n\n        sleep(1);\n    }\n\n    embedids_cleanup(&amp;context);\n    return 0;\n}\n</code></pre>"},{"location":"quickstart/#compile-and-run","title":"Compile and Run","text":"<pre><code>gcc -o my_monitor my_monitor.c -L. -lembedids -I../include\n./my_monitor\n</code></pre>"},{"location":"quickstart/#expected-output","title":"Expected Output","text":"<pre><code>\ud83d\udd12 CPU Monitor Started (threshold: 80%)\n\n\u2705 CPU: 30.0% - Normal\n\u2705 CPU: 38.0% - Normal\n\u2705 CPU: 46.0% - Normal\n\u2705 CPU: 54.0% - Normal\n\u2705 CPU: 62.0% - Normal\n\u2705 CPU: 70.0% - Normal\n\u2705 CPU: 78.0% - Normal\n\ud83d\udea8 CPU: 86.0% - ALERT!\n\ud83d\udea8 CPU: 94.0% - ALERT!\n\ud83d\udea8 CPU: 102.0% - ALERT!\n</code></pre>"},{"location":"quickstart/#what-just-happened","title":"What Just Happened?","text":"<ol> <li>Created a metric: CPU usage with 50-point history</li> <li>Added detection: Threshold algorithm at 80%</li> <li>Monitored in real-time: Added data points and analyzed</li> <li>Got alerts: When CPU exceeded threshold</li> </ol>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Multiple metrics: Monitor CPU, memory, network together</li> <li>Custom algorithms: Implement your own detection logic</li> <li>Advanced features: Trend analysis, pattern detection</li> <li>Real sensors: Replace simulated data with actual sensor readings</li> </ul> <p>See the full tutorial for comprehensive examples and advanced usage!</p>"},{"location":"quickstart/#quick-reference","title":"Quick Reference","text":""},{"location":"quickstart/#core-functions","title":"Core Functions","text":"<pre><code>embedids_init(&amp;context, &amp;config)             // Initialize system\nembedids_add_datapoint(&amp;context, name, val, time) // Add sensor data\nembedids_analyze_metric(&amp;context, name)      // Check one metric\nembedids_analyze_all(&amp;context)               // Check all metrics\nembedids_cleanup(&amp;context)                   // Shutdown system\n</code></pre>"},{"location":"quickstart/#algorithm-types","title":"Algorithm Types","text":"<ul> <li><code>EMBEDIDS_ALGORITHM_THRESHOLD</code> - Simple min/max limits</li> <li><code>EMBEDIDS_ALGORITHM_TREND</code> - Slope analysis over time</li> <li><code>EMBEDIDS_ALGORITHM_CUSTOM</code> - Your own detection logic</li> </ul>"},{"location":"quickstart/#return-codes","title":"Return Codes","text":"<ul> <li><code>EMBEDIDS_OK</code> - All normal</li> <li><code>EMBEDIDS_ERROR_THRESHOLD_EXCEEDED</code> - Threat detected</li> <li><code>EMBEDIDS_ERROR_NOT_INITIALIZED</code> - Call init first</li> <li><code>EMBEDIDS_ERROR_METRIC_NOT_FOUND</code> - Check metric name</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#tutorial","title":"Tutorial","text":""},{"location":"tutorial/#introduction","title":"Introduction","text":"<p>EmbedIDS is a lightweight, extensible intrusion detection system designed for embedded devices and IoT systems. It provides real-time monitoring of system metrics with configurable detection algorithms.</p>"},{"location":"tutorial/#key-features","title":"Key Features","text":"<ul> <li>User-managed memory: No dynamic allocation, perfect for embedded systems</li> <li>Stateless design: Context-based API for thread safety and multiple instances</li> <li>Extensible architecture: Custom metrics and algorithms</li> <li>Multiple detection methods: Thresholds, trends, statistical analysis, and custom algorithms</li> <li>Minimal footprint: Optimized for resource-constrained environments</li> <li>Real-time analysis: Low-latency threat detection</li> </ul>"},{"location":"tutorial/#api-design","title":"API Design","text":""},{"location":"tutorial/#stateless-architecture","title":"Stateless Architecture","text":"<p>EmbedIDS uses a stateless design where all library state is managed through a user-provided context object (<code>embedids_context_t</code>). This design provides several benefits:</p> <ul> <li>Thread Safety: Multiple contexts can be used independently across threads</li> <li>Multiple Instances: Create separate EmbedIDS instances for different subsystems</li> <li>Clear Ownership: Users control the lifecycle of the context object</li> <li>Embedded-Friendly: No global state that could cause issues in embedded systems</li> </ul> <pre><code>// Create and initialize a context\nembedids_context_t context;\nmemset(&amp;context, 0, sizeof(context));\n\n// Pass context to all API calls\nembedids_init(&amp;context, &amp;config);\nembedids_add_datapoint(&amp;context, \"metric_name\", value, timestamp);\nembedids_analyze_metric(&amp;context, \"metric_name\");\nembedids_cleanup(&amp;context);\n</code></pre>"},{"location":"tutorial/#getting-started","title":"Getting Started","text":""},{"location":"tutorial/#installation","title":"Installation","text":"<ol> <li> <p>Clone the repository: </p><pre><code>git clone https://github.com/samiralavi/EmbedIDS.git\ncd EmbedIDS\n</code></pre><p></p> </li> <li> <p>Build the library: </p><pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake\n</code></pre><p></p> </li> <li> <p>Include in your project: </p><pre><code>#include \"embedids.h\"\n</code></pre><p></p> </li> </ol>"},{"location":"tutorial/#basic-project-structure","title":"Basic Project Structure","text":"<pre><code>your_project/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main.c\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 embedids.h\n\u251c\u2500\u2500 lib/\n\u2502   \u2514\u2500\u2500 libembedids.a\n\u2514\u2500\u2500 CMakeLists.txt\n</code></pre>"},{"location":"tutorial/#basic-usage","title":"Basic Usage","text":""},{"location":"tutorial/#step-1-initialize-embedids","title":"Step 1: Initialize EmbedIDS","text":"<p>The simplest way to get started is with an empty configuration:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"embedids.h\"\n\nint main() {\n    // Initialize context and empty configuration\n    embedids_context_t context;\n    memset(&amp;context, 0, sizeof(context));\n\n    embedids_system_config_t config;\n    memset(&amp;config, 0, sizeof(config));\n\n    embedids_result_t result = embedids_init(&amp;context, &amp;config);\n    if (result != EMBEDIDS_OK) {\n        printf(\"Failed to initialize EmbedIDS: %d\\n\", result);\n        return 1;\n    }\n\n    printf(\"EmbedIDS v%s initialized successfully!\\n\", embedids_get_version());\n\n    // Clean up\n    embedids_cleanup(&amp;context);\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/#step-2-basic-metric-monitoring","title":"Step 2: Basic Metric Monitoring","text":"<p>Let's create a simple CPU usage monitor:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include \"embedids.h\"\n\nint main() {\n    // Step 1: Allocate memory for metric history\n    static embedids_metric_datapoint_t cpu_history[100];\n\n    // Step 2: Configure the metric\n    embedids_metric_t cpu_metric;\n    memset(&amp;cpu_metric, 0, sizeof(cpu_metric));\n    strncpy(cpu_metric.name, \"cpu_usage\", EMBEDIDS_MAX_METRIC_NAME_LEN - 1);\n    cpu_metric.type = EMBEDIDS_METRIC_TYPE_PERCENTAGE;\n    cpu_metric.history = cpu_history;\n    cpu_metric.max_history_size = 100;\n    cpu_metric.enabled = true;\n\n    // Step 3: Configure threshold algorithm\n    embedids_algorithm_t threshold_algo;\n    memset(&amp;threshold_algo, 0, sizeof(threshold_algo));\n    threshold_algo.type = EMBEDIDS_ALGORITHM_THRESHOLD;\n    threshold_algo.enabled = true;\n    threshold_algo.config.threshold.max_threshold.f32 = 80.0f;  // 80% threshold\n    threshold_algo.config.threshold.check_max = true;\n    threshold_algo.config.threshold.check_min = false;\n\n    // Step 4: Create metric configuration\n    embedids_metric_config_t metric_config;\n    memset(&amp;metric_config, 0, sizeof(metric_config));\n    metric_config.metric = cpu_metric;\n    metric_config.algorithms[0] = threshold_algo;\n    metric_config.num_algorithms = 1;\n\n    // Step 5: Create system configuration\n    embedids_system_config_t system_config;\n    memset(&amp;system_config, 0, sizeof(system_config));\n    system_config.metrics = &amp;metric_config;\n    system_config.max_metrics = 1;\n    system_config.num_active_metrics = 1;\n\n    // Step 6: Initialize EmbedIDS context and system\n    embedids_context_t context;\n    memset(&amp;context, 0, sizeof(context));\n\n    embedids_result_t result = embedids_init(&amp;context, &amp;system_config);\n    if (result != EMBEDIDS_OK) {\n        printf(\"Failed to initialize EmbedIDS: %d\\n\", result);\n        return 1;\n    }\n\n    printf(\"CPU monitoring started (threshold: 80%%)\\n\");\n\n    // Step 7: Monitoring loop\n    for (int i = 0; i &lt; 10; i++) {\n        // Simulate CPU usage data\n        float cpu_usage = 30.0f + (i * 7.0f);  // Gradually increasing\n\n        // Add data point\n        embedids_metric_value_t value = {.f32 = cpu_usage};\n        uint64_t timestamp = (uint64_t)time(NULL) * 1000;\n\n        result = embedids_add_datapoint(&amp;context, &amp;context, \"cpu_usage\", value, timestamp);\n        if (result != EMBEDIDS_OK) {\n            printf(\"Failed to add data point: %d\\n\", result);\n            continue;\n        }\n\n        // Analyze the metric\n        result = embedids_analyze_metric(&amp;context, &amp;context, \"cpu_usage\");\n        if (result == EMBEDIDS_OK) {\n            printf(\"Iteration %d: CPU %.1f%% - NORMAL\\n\", i+1, cpu_usage);\n        } else {\n            printf(\"Iteration %d: CPU %.1f%% - ALERT! Threshold exceeded\\n\", i+1, cpu_usage);\n        }\n\n        sleep(1);\n    }\n\n    embedids_cleanup(&amp;context);\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"tutorial/#multiple-metrics-with-different-algorithms","title":"Multiple Metrics with Different Algorithms","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include \"embedids.h\"\n\n// Function to simulate realistic sensor data\nfloat get_cpu_usage() {\n    return 20.0f + (rand() % 60);  // 20-80%\n}\n\nfloat get_memory_usage() {\n    return 30.0f + (rand() % 50);  // 30-80%\n}\n\nfloat get_network_packets() {\n    return 100.0f + (rand() % 500);  // 100-600 packets/s\n}\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    // Allocate memory for each metric\n    static embedids_metric_datapoint_t cpu_history[50];\n    static embedids_metric_datapoint_t memory_history[50];\n    static embedids_metric_datapoint_t network_history[30];\n\n    // ===== CPU Metric =====\n    embedids_metric_t cpu_metric;\n    memset(&amp;cpu_metric, 0, sizeof(cpu_metric));\n    strncpy(cpu_metric.name, \"cpu_usage\", EMBEDIDS_MAX_METRIC_NAME_LEN - 1);\n    cpu_metric.type = EMBEDIDS_METRIC_TYPE_PERCENTAGE;\n    cpu_metric.history = cpu_history;\n    cpu_metric.max_history_size = 50;\n    cpu_metric.enabled = true;\n\n    // CPU: Threshold algorithm\n    embedids_algorithm_t cpu_threshold;\n    memset(&amp;cpu_threshold, 0, sizeof(cpu_threshold));\n    cpu_threshold.type = EMBEDIDS_ALGORITHM_THRESHOLD;\n    cpu_threshold.enabled = true;\n    cpu_threshold.config.threshold.max_threshold.f32 = 75.0f;\n    cpu_threshold.config.threshold.check_max = true;\n    cpu_threshold.config.threshold.check_min = false;\n\n    embedids_metric_config_t cpu_config;\n    memset(&amp;cpu_config, 0, sizeof(cpu_config));\n    cpu_config.metric = cpu_metric;\n    cpu_config.algorithms[0] = cpu_threshold;\n    cpu_config.num_algorithms = 1;\n\n    // ===== Memory Metric =====\n    embedids_metric_t memory_metric;\n    memset(&amp;memory_metric, 0, sizeof(memory_metric));\n    strncpy(memory_metric.name, \"memory_usage\", EMBEDIDS_MAX_METRIC_NAME_LEN - 1);\n    memory_metric.type = EMBEDIDS_METRIC_TYPE_PERCENTAGE;\n    memory_metric.history = memory_history;\n    memory_metric.max_history_size = 50;\n    memory_metric.enabled = true;\n\n    // Memory: Trend algorithm\n    embedids_algorithm_t memory_trend;\n    memset(&amp;memory_trend, 0, sizeof(memory_trend));\n    memory_trend.type = EMBEDIDS_ALGORITHM_TREND;\n    memory_trend.enabled = true;\n    memory_trend.config.trend.window_size = 5;\n    memory_trend.config.trend.max_slope = 10.0f;  // Max 10% increase per window\n\n    embedids_metric_config_t memory_config;\n    memset(&amp;memory_config, 0, sizeof(memory_config));\n    memory_config.metric = memory_metric;\n    memory_config.algorithms[0] = memory_trend;\n    memory_config.num_algorithms = 1;\n\n    // ===== Network Metric =====\n    embedids_metric_t network_metric;\n    memset(&amp;network_metric, 0, sizeof(network_metric));\n    strncpy(network_metric.name, \"network_packets\", EMBEDIDS_MAX_METRIC_NAME_LEN - 1);\n    network_metric.type = EMBEDIDS_METRIC_TYPE_FLOAT;\n    network_metric.history = network_history;\n    network_metric.max_history_size = 30;\n    network_metric.enabled = true;\n\n    // Network: Threshold algorithm\n    embedids_algorithm_t network_threshold;\n    memset(&amp;network_threshold, 0, sizeof(network_threshold));\n    network_threshold.type = EMBEDIDS_ALGORITHM_THRESHOLD;\n    network_threshold.enabled = true;\n    network_threshold.config.threshold.max_threshold.f32 = 500.0f;\n    network_threshold.config.threshold.check_max = true;\n    network_threshold.config.threshold.check_min = false;\n\n    embedids_metric_config_t network_config;\n    memset(&amp;network_config, 0, sizeof(network_config));\n    network_config.metric = network_metric;\n    network_config.algorithms[0] = network_threshold;\n    network_config.num_algorithms = 1;\n\n    // ===== System Configuration =====\n    embedids_metric_config_t metrics[3] = {cpu_config, memory_config, network_config};\n\n    embedids_system_config_t system_config;\n    memset(&amp;system_config, 0, sizeof(system_config));\n    system_config.metrics = metrics;\n    system_config.max_metrics = 3;\n    system_config.num_active_metrics = 3;\n\n    // Initialize EmbedIDS context and system\n    embedids_context_t context;\n    memset(&amp;context, 0, sizeof(context));\n\n    embedids_result_t result = embedids_init(&amp;context, &amp;system_config);\n    if (result != EMBEDIDS_OK) {\n        printf(\"Failed to initialize EmbedIDS: %d\\n\", result);\n        return 1;\n    }\n\n    printf(\"Multi-metric monitoring started:\\n\");\n    printf(\"- CPU: Threshold (75%%)\\n\");\n    printf(\"- Memory: Trend analysis (5 window, 10%% max slope)\\n\");\n    printf(\"- Network: Threshold (500 pkt/s)\\n\\n\");\n\n    // Monitoring loop\n    for (int i = 0; i &lt; 15; i++) {\n        // Get sensor data\n        float cpu = get_cpu_usage();\n        float memory = get_memory_usage();\n        float network = get_network_packets();\n\n        // Add data points\n        uint64_t timestamp = (uint64_t)time(NULL) * 1000 + i * 100;\n\n        embedids_metric_value_t cpu_val = {.f32 = cpu};\n        embedids_metric_value_t memory_val = {.f32 = memory};\n        embedids_metric_value_t network_val = {.f32 = network};\n\n        embedids_add_datapoint(&amp;context, \"cpu_usage\", cpu_val, timestamp);\n        embedids_add_datapoint(&amp;context, \"memory_usage\", memory_val, timestamp);\n        embedids_add_datapoint(&amp;context, \"network_packets\", network_val, timestamp);\n\n        // Analyze all metrics\n        embedids_result_t overall_result = embedids_analyze_all(&amp;context);\n\n        printf(\"Iteration %2d: CPU=%4.1f%%, Memory=%4.1f%%, Network=%5.0f pkt/s \", \n               i+1, cpu, memory, network);\n\n        if (overall_result == EMBEDIDS_OK) {\n            printf(\"\u2705 SECURE\\n\");\n        } else {\n            printf(\"\ud83d\udea8 THREAT DETECTED\\n\");\n        }\n\n        usleep(200000);  // 200ms delay\n    }\n\n    embedids_cleanup(&amp;context);\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/#custom-algorithms","title":"Custom Algorithms","text":""},{"location":"tutorial/#creating-a-custom-detection-algorithm","title":"Creating a Custom Detection Algorithm","text":"<p>Custom algorithms allow you to implement specialized detection logic:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include \"embedids.h\"\n\n// Custom algorithm context\ntypedef struct {\n    float baseline;\n    uint32_t violation_count;\n    uint32_t max_violations;\n} anomaly_detector_context_t;\n\n// Custom algorithm implementation\nembedids_result_t anomaly_detector(const embedids_metric_t* metric,\n                                 const void* config,\n                                 void* context) {\n    (void)config;  // Unused in this example\n\n    anomaly_detector_context_t* ctx = (anomaly_detector_context_t*)context;\n\n    if (metric-&gt;current_size &lt; 3) {\n        return EMBEDIDS_OK;  // Need at least 3 data points\n    }\n\n    // Get recent values\n    uint32_t idx1 = (metric-&gt;write_index - 1) % metric-&gt;max_history_size;\n    uint32_t idx2 = (metric-&gt;write_index - 2) % metric-&gt;max_history_size;\n    uint32_t idx3 = (metric-&gt;write_index - 3) % metric-&gt;max_history_size;\n\n    float val1 = metric-&gt;history[idx1].value.f32;\n    float val2 = metric-&gt;history[idx2].value.f32;\n    float val3 = metric-&gt;history[idx3].value.f32;\n\n    // Calculate moving average\n    float avg = (val1 + val2 + val3) / 3.0f;\n\n    // Check deviation from baseline\n    float deviation = fabs(avg - ctx-&gt;baseline);\n    float threshold = ctx-&gt;baseline * 0.5f;  // 50% deviation threshold\n\n    if (deviation &gt; threshold) {\n        ctx-&gt;violation_count++;\n        printf(\"  \ud83d\udd0d Anomaly detector: deviation %.2f from baseline %.2f (count: %d)\\n\",\n               deviation, ctx-&gt;baseline, ctx-&gt;violation_count);\n\n        if (ctx-&gt;violation_count &gt;= ctx-&gt;max_violations) {\n            printf(\"  \ud83d\udea8 ANOMALY ALERT: Sustained deviation detected!\\n\");\n            ctx-&gt;violation_count = 0;  // Reset counter\n            return EMBEDIDS_ERROR_THRESHOLD_EXCEEDED;\n        }\n    } else {\n        ctx-&gt;violation_count = 0;  // Reset on normal reading\n    }\n\n    return EMBEDIDS_OK;\n}\n\nint main() {\n    // User-managed memory\n    static embedids_metric_datapoint_t sensor_history[40];\n\n    // Custom algorithm context\n    anomaly_detector_context_t detector_ctx = {\n        .baseline = 50.0f,\n        .violation_count = 0,\n        .max_violations = 3\n    };\n\n    // Configure metric\n    embedids_metric_t sensor_metric;\n    memset(&amp;sensor_metric, 0, sizeof(sensor_metric));\n    strncpy(sensor_metric.name, \"sensor_data\", EMBEDIDS_MAX_METRIC_NAME_LEN - 1);\n    sensor_metric.type = EMBEDIDS_METRIC_TYPE_FLOAT;\n    sensor_metric.history = sensor_history;\n    sensor_metric.max_history_size = 40;\n    sensor_metric.enabled = true;\n\n    // Configure custom algorithm\n    embedids_algorithm_t custom_algo;\n    memset(&amp;custom_algo, 0, sizeof(custom_algo));\n    custom_algo.type = EMBEDIDS_ALGORITHM_CUSTOM;\n    custom_algo.enabled = true;\n    custom_algo.config.custom.function = anomaly_detector;\n    custom_algo.config.custom.config = NULL;\n    custom_algo.config.custom.context = &amp;detector_ctx;\n\n    // Configure threshold algorithm as backup\n    embedids_algorithm_t threshold_algo;\n    memset(&amp;threshold_algo, 0, sizeof(threshold_algo));\n    threshold_algo.type = EMBEDIDS_ALGORITHM_THRESHOLD;\n    threshold_algo.enabled = true;\n    threshold_algo.config.threshold.max_threshold.f32 = 100.0f;\n    threshold_algo.config.threshold.min_threshold.f32 = 0.0f;\n    threshold_algo.config.threshold.check_max = true;\n    threshold_algo.config.threshold.check_min = true;\n\n    // Metric configuration with multiple algorithms\n    embedids_metric_config_t metric_config;\n    memset(&amp;metric_config, 0, sizeof(metric_config));\n    metric_config.metric = sensor_metric;\n    metric_config.algorithms[0] = custom_algo;      // Custom algorithm first\n    metric_config.algorithms[1] = threshold_algo;   // Threshold as backup\n    metric_config.num_algorithms = 2;\n\n    // System configuration\n    embedids_system_config_t system_config;\n    memset(&amp;system_config, 0, sizeof(system_config));\n    system_config.metrics = &amp;metric_config;\n    system_config.max_metrics = 1;\n    system_config.num_active_metrics = 1;\n\n    // Initialize context and system\n    embedids_context_t context;\n    memset(&amp;context, 0, sizeof(context));\n\n    embedids_result_t result = embedids_init(&amp;context, &amp;system_config);\n    if (result != EMBEDIDS_OK) {\n        printf(\"Failed to initialize EmbedIDS: %d\\n\", result);\n        return 1;\n    }\n\n    printf(\"Custom algorithm demo started (baseline: %.1f)\\n\", detector_ctx.baseline);\n    printf(\"Algorithms: Custom Anomaly Detector + Threshold (0-100)\\n\\n\");\n\n    // Simulate sensor data with anomalies\n    float sensor_values[] = {\n        48.0, 52.0, 49.0, 51.0, 47.0,  // Normal data around baseline\n        85.0, 88.0, 90.0,              // Anomaly: high values\n        45.0, 50.0, 48.0,              // Back to normal\n        15.0, 12.0, 18.0,              // Anomaly: low values\n        52.0, 49.0, 51.0               // Normal again\n    };\n\n    int num_values = sizeof(sensor_values) / sizeof(sensor_values[0]);\n\n    for (int i = 0; i &lt; num_values; i++) {\n        float value = sensor_values[i];\n\n        // Add data point\n        embedids_metric_value_t val = {.f32 = value};\n        uint64_t timestamp = (uint64_t)time(NULL) * 1000 + i * 100;\n\n        embedids_add_datapoint(&amp;context, \"sensor_data\", val, timestamp);\n\n        // Analyze\n        result = embedids_analyze_metric(&amp;context, \"sensor_data\");\n\n        printf(\"Sample %2d: Value=%.1f \", i+1, value);\n        if (result == EMBEDIDS_OK) {\n            printf(\"\u2705 NORMAL\\n\");\n        } else {\n            printf(\"\ud83d\udea8 ANOMALY DETECTED\\n\");\n        }\n\n        usleep(300000);  // 300ms delay\n    }\n\n    embedids_cleanup(&amp;context);\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/#best-practices","title":"Best Practices","text":""},{"location":"tutorial/#1-memory-management","title":"1. Memory Management","text":"<pre><code>// \u2705 Good: Static allocation for embedded systems\nstatic embedids_metric_datapoint_t history[100];\n\n// \u274c Avoid: Dynamic allocation in embedded systems\n// embedids_metric_datapoint_t* history = malloc(sizeof(embedids_metric_datapoint_t) * 100);\n</code></pre>"},{"location":"tutorial/#2-error-handling","title":"2. Error Handling","text":"<pre><code>// \u2705 Always check return codes\nembedids_result_t result = embedids_add_datapoint(&amp;context, \"metric\", value, timestamp);\nif (result != EMBEDIDS_OK) {\n    handle_error(result);\n}\n\n// \u2705 Handle specific error types\nswitch (result) {\n    case EMBEDIDS_ERROR_NOT_INITIALIZED:\n        reinitialize_system();\n        break;\n    case EMBEDIDS_ERROR_METRIC_NOT_FOUND:\n        log_error(\"Unknown metric\");\n        break;\n    case EMBEDIDS_ERROR_BUFFER_FULL:\n        // This is expected behavior with circular buffers\n        break;\n    default:\n        handle_generic_error(result);\n}\n</code></pre>"},{"location":"tutorial/#3-metric-configuration","title":"3. Metric Configuration","text":"<pre><code>// \u2705 Use appropriate history sizes\nembedids_metric_t fast_metric = {\n    .max_history_size = 20,  // For high-frequency data\n    // ...\n};\n\nembedids_metric_t slow_metric = {\n    .max_history_size = 100, // For trend analysis\n    // ...\n};\n\n// \u2705 Choose appropriate thresholds\nthreshold_config.max_threshold.f32 = 85.0f;  // 85% CPU threshold\nthreshold_config.min_threshold.f32 = 5.0f;   // Minimum activity level\n</code></pre>"},{"location":"tutorial/#4-performance-optimization","title":"4. Performance Optimization","text":"<pre><code>// \u2705 Batch operations when possible\nfor (int i = 0; i &lt; num_sensors; i++) {\n    embedids_add_datapoint(&amp;context, sensor_names[i], values[i], timestamp);\n}\n// Analyze all at once\nembedids_analyze_all(&amp;context);\n\n// \u2705 Use appropriate data types\nembedids_metric_value_t percentage_val = {.f32 = 75.5f};  // For percentages\nembedids_metric_value_t count_val = {.u32 = 1024};        // For counts\n</code></pre>"},{"location":"tutorial/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorial/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"tutorial/#1-initialization-fails","title":"1. Initialization Fails","text":"<pre><code>embedids_result_t result = embedids_init(&amp;context, &amp;config);\nif (result == EMBEDIDS_ERROR_INVALID_PARAM) {\n    // Check: config pointer is not NULL\n    // Check: metric configurations are valid\n    // Check: algorithm configurations are correct\n}\n</code></pre>"},{"location":"tutorial/#2-metric-not-found","title":"2. Metric Not Found","text":"<pre><code>result = embedids_add_datapoint(&amp;context, \"cpu_usage\", value, timestamp);\nif (result == EMBEDIDS_ERROR_METRIC_NOT_FOUND) {\n    // Verify metric name matches exactly (case-sensitive)\n    // Ensure metric was added to system configuration\n    // Check metric is enabled\n}\n</code></pre>"},{"location":"tutorial/#3-memory-issues","title":"3. Memory Issues","text":"<pre><code>// Ensure history arrays are large enough\nstatic embedids_metric_datapoint_t history[SIZE];\nif (SIZE &lt; expected_data_points) {\n    // Increase SIZE or reduce data retention period\n}\n</code></pre>"},{"location":"tutorial/#4-algorithm-not-triggering","title":"4. Algorithm Not Triggering","text":"<pre><code>// Check algorithm configuration\nthreshold_algo.enabled = true;  // Must be enabled\nthreshold_algo.config.threshold.check_max = true;  // Must enable checking\n\n// Verify threshold values\nprintf(\"Threshold: %.2f, Current: %.2f\\n\", \n       threshold_config.max_threshold.f32, current_value);\n</code></pre>"},{"location":"tutorial/#debug-information","title":"Debug Information","text":"<pre><code>// Check system status\nif (embedids_is_initialized()) {\n    printf(\"EmbedIDS is running\\n\");\n} else {\n    printf(\"EmbedIDS not initialized\\n\");\n}\n\n// Get version info\nprintf(\"EmbedIDS version: %s\\n\", embedids_get_version());\n\n// Monitor metric states\nfor (int i = 0; i &lt; num_metrics; i++) {\n    printf(\"Metric %s: %d/%d data points\\n\", \n           metric_names[i], \n           metrics[i].current_size, \n           metrics[i].max_history_size);\n}\n</code></pre>"},{"location":"tutorial/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>#include &lt;time.h&gt;\n\n// Measure analysis performance\nclock_t start = clock();\nembedids_result_t result = embedids_analyze_all(&amp;context);\nclock_t end = clock();\n\ndouble cpu_time = ((double)(end - start)) / CLOCKS_PER_SEC;\nprintf(\"Analysis took %.3f ms\\n\", cpu_time * 1000);\n</code></pre>"},{"location":"tutorial/#conclusion","title":"Conclusion","text":"<p>EmbedIDS provides a flexible, efficient intrusion detection framework for embedded systems. Key takeaways:</p> <ol> <li>Start simple with basic threshold monitoring</li> <li>Use user-managed memory for predictable resource usage</li> <li>Combine multiple algorithms for comprehensive detection</li> <li>Implement custom algorithms for specialized requirements</li> <li>Follow embedded best practices for reliable operation</li> </ol> <p>For more examples, see the <code>examples/</code> directory in the EmbedIDS repository.</p> <p>Next Steps: - Try the provided examples - Implement custom algorithms for your use case - Integrate with your existing monitoring infrastructure - Explore advanced configuration options</p>"},{"location":"blog/","title":"Index","text":""}]}